# -*- coding: utf-8 -*-
"""Pratica_MLP

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LM5q43bbIv0slxSVPNRqY4LF8laZIVYy

# MLP - Multilayer Perceptron 
* Visualização: https://playground.tensorflow.org/ 

## Problema de Classificação
* **Identificar se um determinado asteroide é perigoso ou não**  
* **SUV - Checar essa informação.** 


Fonte: [MLP](https://www.kaggle.com/shrutimehta/nasa-asteroids-classification)

## Carregando os Dados
"""

import pandas as pd

dataset = pd.read_csv("https://raw.githubusercontent.com/albathalita/MLP_Keras/main/nasa.csv")

# Transformar uma coluna de str em int
dataset['Hazardous'] = dataset['Hazardous'].astype(int)

dataset.head()

dataset.describe()

"""## Escolhendo atributos 
* Magnitude Absluta e Velociade Relativa Km/h
"""

X = dataset.loc[:,['Absolute Magnitude','Relative Velocity km per hr']].values
# ou 
# X = dataset.iloc[:,2:14].values

y = dataset['Hazardous'].values
# ou 
# y = dataset.iloc[:,39].values

print(X[0:6,:])

y[0:10]

"""## Separando entre conjuntos de treinamento e teste"""

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.25, random_state = 0)

"""## Normalização 
* A amplitude de variação dos dados são bem diferentes
* Permite que a faixa de variação seja equilibrada entre os diferentes atributos 
* Muitos algoritmos de aprendizado de máquinas são sensíveis a atribuitos com aplitude de valores muito distintos 
* Vídeo com explicações: https://youtu.be/kIeXOC-Rnb4 
"""

# Fonte: https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html 
from sklearn.preprocessing import MinMaxScaler

sc = MinMaxScaler()

X_train = sc.fit_transform(X_train) 
# Fit é quando precisa fazer ajuste (Só usa uma vez)

X_test = sc.transform(X_test)

"""## Treinamento"""

import tensorflow as tf

"""### Construíndo a estrutra da rede 
* Arquitetura 
"""

# Inicialização 
classifier = tf.keras.models.Sequential()

# Adicionando a camada de entrada e a primeira camada escondida  
classifier.add( tf.keras.layers.Dense( activation = 'relu', input_dim = 2, units = 4, kernel_initializer = 'uniform'))
# (função de ativação, quantidade de entrada, quantidade de neurônios, pesos)

# Adicionando a camada de saída 
classifier.add( tf.keras.layers.Dense( activation = 'sigmoid', units = 1, kernel_initializer = 'uniform'))
# (sigmoi - suavizar a resposta porque ajuda no treinamento, neurônio de saída, pesos)

# Montando a Rede 
classifier.compile(optimizer = 'adam', loss = 'binary_crossentropy', metrics = ['accuracy'])

"""### Executando o treinamento """

classifier.fit(X_train, y_train, batch_size = 1, epochs = 81)
# batch_size - apresenta a amostra, recebe uma resposta e compara com a desejada
#       calcula o erro e disso ajusta o modelo.

# Quanto menor o valor do batch_size, mais tempo irá demorar

"""## Avaliando do Modelo"""

y_pred = classifier.predict(X_test)

print(y_test[0:35])
print(y_pred[0:35])

y_pred_bin = [ ( 1 if elem > 0.5 else 0) for elem in y_pred ]

import numpy as np

y_pred_bin =  np.array(y_pred_bin)

print(y_test[0:35])
print(y_pred_bin[0:35])

from sklearn.metrics import accuracy_score

print("Acurácia: ", accuracy_score(y_test,y_pred_bin)*100, "%"  )

from sklearn.metrics import confusion_matrix
cm = confusion_matrix(y_test, y_pred_bin)
print("Matrix de confusão: ")
print(cm)

"""## Visualizando os resultados


"""

import matplotlib.pyplot as plt

# Seleção dos elementos classificados como negativos (perigoso)
mag_neg = X_train[y_train == 0, 0]
vel_neg = X_train[y_train == 0, 1]
mag_pos = X_train[y_train == 1, 0]
vel_pos = X_train[y_train == 1, 1]

plt.scatter(mag_pos,vel_pos, color='green', label = 'Seguro')
plt.scatter(mag_neg,vel_neg, color='red', label = 'Perigoso')

plt.title('SVM - Conjunto de Treinamento')
plt.xlabel('Magnitude Absoluta')
plt.ylabel('Velocidade Relativa')
plt.legend()
plt.show()

vx = np.arange(-0.1, 1.1, 0.025) 
vy = np.arange(-0.1, 1.1, 0.025)
X1, X2 = np.meshgrid(vx,vy) 

y_pred_mesh =  classifier.predict(np.array([X1.ravel(),X2.ravel()]).T ).reshape(X1.shape)

from matplotlib.colors import ListedColormap
plt.contourf(X1,X2, y_pred_mesh, alpha  = 0.5, cmap = ListedColormap(('red','green')))

mag_neg = X_test[y_test == 0, 0]
vel_neg = X_test[y_test == 0, 1]
mag_pos = X_test[y_test == 1, 0]
vel_pos = X_test[y_test == 1, 1]

plt.contourf(X1,X2, y_pred_mesh, alpha  = 0.5, cmap = ListedColormap(('red','green')))

plt.scatter(mag_pos,vel_pos, color='green', label = 'Seguro')
plt.scatter(mag_neg,vel_neg, color='red', label = 'Perigoso')

plt.title('SVM - Conjunto de Treinamento')
plt.xlabel('Magnitude Absoluta')
plt.ylabel('Velocidade Relativa')
plt.legend()
plt.show()

y_pred_mesh[30:35,40:45]